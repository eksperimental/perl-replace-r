#!/bin/bash

# perl-replace-r : Search and replace recursively.
# For more information about this project, visit:
# https://github.com/eksperimental/perl-replace-r
# License: Publlic Domain
# Usage: perl-replace-r -h 
perl-replace-r() {
  local APP="perl-replace-r"
  local APP_NAME="Perl Replace Recursively"
  local APP_VERSION="0.0.3"

__perl-replace-r-help() {
cat << EOF
${APP} – ${APP_NAME}
Search and replace recursively.
It uses a combination both of the fastest tools for the job:
* "ag" (the silver searcher) – for searching the files
* perl for actually doing the string substitutions them.

Usage: ${APP} [-digmuvDVh] SEARCH_PATTERN REPLACE_PATTERN [SEARCH-OPTIONS] [PATH]

  -d           Dry-run. Do not execute any replacements.
                 List the files that matched the SEARCH pattern.
  -D           Print debug info as the commands are run
  -i           Case insensitive
  -f           Follow symlinks
  -g           Global replacement (replaces all occurrences)
  -h           Shows this help menu
  -m           Multi-line replacement
  -u           Unrestricted search. ignores "ignore files" such us .gitignore, .agignore
                 By default files listed in these files are ignored
  -v           Verbose
  -V           Print version number

  SEARCH       search regular expression
  REPLACE      replace regular expression
  SEARCH-OPTS  pass multiple options to "ag" (the silver searcher),
                 such as "--ignore-dir ./somedir/" and/or "--ignore *.ext"
  PATH         multiple directory or file to look for files.
                 e.g. "dir1" "dir2"

Example:
  # replace all occurences of "alpha" (case insensitive) with "beta"
  perl-replace-r -ig "alpha" "beta" 
 
  # replace recusirvely all occurrences of "Mon-Fri" with "Fri-Sun" (case sensitive)
  perl-replace-r -g "(Mon)-(Fri)" "\$2-Sun" 
EOF
}

__perl-replace-r-version() {
  echo "${APP} ${APP_VERSION}"
}

# __perl-replace-r-search-command SEARCH_FLAGS SEARCH_PATTERN PATH
__perl-replace-r-search-command() {
  ag ${1} -- "${2}" "${@:3}"
}

# __perl-replace-r-build-search-command SEARCH_FLAGS SEARCH_PATTERN PATH
__perl-replace-r-build-search-command() {
  echo "ag ${1} -- \"${2}\" ${*:3}"
}

# __perl-replace-r-replace-command REPLACE_FLAGS SEARCH_PATTERN REPLACE_PATTERN FILES 
__perl-replace-r-replace-command() {
  echo "${@:4}" | xargs perl -pi -CSA -e "s/${2}/${3}/${1}"
}

# __perl-replace-r-build-replace-command REPLACE_FLAGS SEARCH_PATTERN REPLACE_PATTERN
__perl-replace-r-build-replace-command() {
  echo "perl -pi -CSA -e \"s/${2}/${3}/${1}\""
}

  # Check requirements
  command -v ag >/dev/null 2>&1 || {
    echo >&2 "\"ag\" is required. Please get it from: https://github.com/ggreer/the_silver_searcher/"
    return 1
  }
  command -v perl >/dev/null 2>&1 || {
    echo >&2 "\"perl\" is required. Please get it from: https://www.perl.org/get.html"
    return 1
  }

  # http://mywiki.wooledge.org/BashFAQ/035#getopts
  # A POSIX variable
  OPTIND=1 # Reset in case getopts has been used previously in the shell.

  # Initialize our own variables:
  # flags
  local search_flags="-l"
  local replace_flags=""
  # args
  local f_dry_run=0
  local f_debug=0
  local f_insensitive=0
  local f_follow_symlinks=0
  local f_global=0
  local f_help=0
  local f_multiline=0
  local f_unrestricted=0
  local f_verbose=0
  local f_version=0

  while getopts ":dDifgmuvhV" opt; do
    case "$opt" in
    d)  f_dry_run=1
        ;;
    D)  f_debug=1
        ;;
    i)  f_insensitive=1
        ;;
    f)  f_follow_symlinks=1
        ;;
    g)  f_global=1
        ;;
    h)  f_help=1
        __perl-replace-r-help
        return 0
        ;;
    m)  f_multiline=1
        ;;
    u)  f_unrestricted=1
        ;;
    v)  f_verbose=1
        ;;
    V)  f_version=1
        ;;
    \?) echo "* [ERROR] An invalid option has been entered: ${OPTARG}" >&2
        return 1
        ;;
    esac
  done

  shift $((OPTIND-1))

  [ "$1" = "--" ] && shift

  # check arguments first, before disastrous things may happen
  if [ -z "${1+nothing}" ]; then
    __perl-replace-r-help
    return 1
  fi
  if [ -z "${2+nothing}" ]; then
    echo "* [ERROR]: Please provide REPLACE argument" >&2
    return 1
  fi

  # define variables
  local search_pattern="${1}"
  local replace_pattern="${2}"
  local -a path=( "${@:3}" )
  if [ ${#path[@]} -eq 0 ]; then
    path=( ./ )
  fi

  local replace_command="$(__perl-replace-r-build-replace-command "${replace_flags}" "${search_pattern}" "${replace_pattern}")"
  local search_command="$(__perl-replace-r-build-search-command ${search_flags} "${search_pattern}" "${path[@]}")"

  # DEBUG
  if [ $f_debug -eq 1 ]; then
    echo "* DEBUGGING INFORMATION *" >&2
    echo "version:" >&2
    echo "  $(__perl-replace-r-version | cut -d" " -f2)" >&2
    echo "flags:" >&2
    echo "  -d: ${f_dry_run}" >&2
    echo "  -i: ${f_insensitive}" >&2
    echo "  -f: ${f_follow_symlinks}" >&2
    echo "  -g: ${f_global}" >&2
    echo "  -h: ${f_help}" >&2
    echo "  -m: ${f_multiline}" >&2
    echo "  -u: ${f_unrestricted}" >&2
    echo "  -v: ${f_verbose}" >&2
    echo "  -D: ${f_debug}" >&2
    echo "  -V: ${f_version}" >&2
    echo "parameters:" >&2
    echo "  SEARCH_PATTERN: ${search_pattern}" >&2
    echo "  REPLACE_PATTERN: ${replace_pattern}" >&2
    echo "  SEARCH-OPTS + PATH: ${path[*]}" >&2
    echo "search command:" >&2
    echo "  ${search_command}" >&2
    echo "replace command:" >&2
    echo " ${replace_command}" >&2
    echo  >&2
  fi

  # Set flags
  if [ $f_insensitive -eq 1 ]; then
    search_flags="${search_flags}i"
    replace_flags="${replace_flags}i"
  else
    search_flags="${search_flags}s"
  fi

  [ $f_follow_symlinks -eq 1 ] && replace_flags="${search_flags}f"
  [ $f_global          -eq 1 ] && replace_flags="${replace_flags}g"
  [ $f_multiline       -eq 1 ] && replace_flags="${replace_flags}m"
  [ $f_unrestricted    -eq 1 ] &&  search_flags="${search_flags}u"

  # AG COMMAND
  local -a files=( $( __perl-replace-r-search-command ${search_flags} "${search_pattern}" "${path[@]}" ) )

  if [ ${#files[@]} -eq 0 ]; then
    echo "${search_command}"
    echo "* No files have matched your search pattern" >&2
  else
    if [ $f_dry_run -eq 0 ]; then
      if [ $f_verbose -eq 1 ]; then 
        echo "* Files that matched your search pattern:"
        echo "${files[@]}"
      fi
      # PERL COMMAND
      echo "${search_command} | xargs ${replace_command}"
      __perl-replace-r-replace-command "${replace_flags}" "${search_pattern}" "${replace_pattern}" "${files[@]}"
    else
      # Dry-run
      echo "${files[@]}"
    fi
  fi
}